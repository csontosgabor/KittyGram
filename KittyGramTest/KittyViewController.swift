//
//  KittyViewController.swift
//  KittyGramTest
//
//  Created by Gabor on 06/07/2017.
//  Copyright © 2017 Gabor. All rights reserved.
//

import Foundation
import UIKit


/*
 
 Naming - inconsistent capitalization (`KittyDatasource`, `disLikePressedWithId`, etc)
 Inconsistent empty lines - sometimes one, sometimes 2, sometimes even more
 `KittyDatasource` init method - lines 23 and 26 are basically the same - can be combined
 `KittyDatasource` many methods return self, but that return value is not used anywhere else. Why is it useful?
 `disLikePressedWithId`
 Why does it work on a copy of the array?
 Why does it not just copy the array - why is the for loop needed?
 Contrary to `disLikePressedWithId`, `disLikePressedAtIndex` doesn't copy the array. Why?
 Images are cached using NSCache, but still if the app runs without an internet connection, previously downloaded images will not show
 Do you think NSCache completely satisfies the app’s caching requirements?
 Images are cached, but not lists of images (the XML)
 There is a commented out completion handler logic in `ImageCacheModel` - why is it still there?
 `KittyToLikeDelegate` uses view tags as indexes. Isn't there a better way?
 Not an error of course, but why are storyboards and/or Xibs not used? It's mostly Auto Layout in code.
 `FavKittyCell` and `KittyViewCell` are basically the same.
 Why is the user ID hardcoded in `LandingPageViewController`?
 Strings are (everywhere) not localizable (NSLocalizedString), but that's not a big deal for an example app
 `LandingPageViewController` has a dependency on `TabBarViewController`
 In `KittyViewController` force unwrapping is used on the collection view property which is not needed
 In `KittyViewController`, in the completion block for fetching kitties, self is used (a string reference). Why not weak?
 In `ShowKittyViewController` and `FavKittyViewController` spacing, brackets and empty lines are especially inconsistent
 `FavKittyViewController` is too long and difficult to understand
 The unit tests section is full of autogenerated or commented code. If there will be no tests, remove those files
 
 */


class KittyViewController: UICollectionViewController {
    
    var userId: String?
    var refresher:UIRefreshControl!
    var dataSource: KittyDatasource? {
        didSet {
            DispatchQueue.main.async {
                self.collectionView?.reloadData()
            }
        }
    }
    
    lazy var networkLabel: UILabel = {
        let label = UILabel()
        label.translatesAutoresizingMaskIntoConstraints = false
        label.lineBreakMode = .byWordWrapping
        label.isHidden = true
        label.textAlignment = .center
        label.font = UIFont.boldSystemFont(ofSize: 12)
        return label
    }()
    
    lazy var catLogo: UIImageView = {
        let img = UIImageView()
        img.contentMode = .scaleAspectFill
        img.translatesAutoresizingMaskIntoConstraints = false
        img.image = UIImage(named: "catLogo")
        return img
    }()
    lazy var spinner: UIActivityIndicatorView = {
        let spinner = UIActivityIndicatorView(activityIndicatorStyle: .whiteLarge)
        spinner.translatesAutoresizingMaskIntoConstraints = false
        spinner.startAnimating()
        return spinner
    }()
    
    func fetchKittyFeed() {
        guard let userId = self.userId else { return }
        self.networkLabel.isHidden = true
        Service.sharedInstance.fetchKitties(userId: userId, completionHandler: { (kittyDatasource, err) in
            if err == nil {
                guard let dataSource = kittyDatasource else { return }
                self.dataSource = dataSource
                self.catLogo.isHidden = true
            } else {
                if self.dataSource != nil && self.dataSource?.numberOfItems() != 0 {
                    self.networkLabel.isHidden = true
                } else {
                    self.networkLabel.isHidden = false
                    self.networkLabel.text = err!.localizedDescription
                }
            }
                if self.refresher.isRefreshing { self.refresher.endRefreshing() }
        })
    }
    
    func catDisliked(_ notification: NSNotification) {
        //setting offline data in KittyViewController
        if let id = notification.userInfo?["id"] as? String {
            self.dataSource?.likeTouched(id, isLiked: false)
            DispatchQueue.main.async {
                self.collectionView?.reloadData()
            }
        }
    }

    func setupCollectionView() {
        self.collectionView?.backgroundColor = UIColor(white: 0.95, alpha: 1)
        self.collectionView?.alwaysBounceVertical = true
        self.collectionView?.register(KittyCollectionViewCell.self, forCellWithReuseIdentifier: "kCell")
        //refresher
        self.refresher = UIRefreshControl()
        self.refresher.tintColor = UIColor.gray
        self.refresher.addTarget(self, action: #selector(fetchKittyFeed), for: .valueChanged)
        self.collectionView?.addSubview(refresher)
        //catLogo
        if !catLogo.isDescendant(of: self.view) { self.view.addSubview(catLogo) }
        catLogo.centerYAnchor.constraint(equalTo: self.view.centerYAnchor).isActive = true
        catLogo.centerXAnchor.constraint(equalTo: self.view.centerXAnchor).isActive = true
        catLogo.widthAnchor.constraint(equalTo: self.view.widthAnchor).isActive = true
        catLogo.heightAnchor.constraint(equalTo: self.view.heightAnchor).isActive = true
        //spinner
        if !spinner.isDescendant(of: self.catLogo) { self.catLogo.addSubview(spinner) }
        spinner.centerYAnchor.constraint(equalTo: self.catLogo.centerYAnchor).isActive = true
        spinner.centerXAnchor.constraint(equalTo: self.catLogo.centerXAnchor).isActive = true
        spinner.widthAnchor.constraint(equalTo: self.catLogo.widthAnchor).isActive = true
        spinner.heightAnchor.constraint(equalTo: self.catLogo.heightAnchor).isActive = true
        //networkLabel x,y,w,h
        if !networkLabel.isDescendant(of: self.view) { self.view.addSubview(networkLabel) }
        networkLabel.centerYAnchor.constraint(equalTo: self.view.centerYAnchor).isActive = true
        networkLabel.centerXAnchor.constraint(equalTo: self.view.centerXAnchor).isActive = true
        networkLabel.widthAnchor.constraint(equalTo: self.view.widthAnchor, multiplier: 0.9).isActive = true
        networkLabel.heightAnchor.constraint(equalToConstant: 50).isActive = true
    }
    
    func setupNotification(){
        let notificationName = Notification.Name("catDislikedNotification")
        NotificationCenter.default.addObserver(self, selector: #selector(catDisliked), name: notificationName, object: nil)
    }
   
    public init(userId: String) {
        self.userId = userId
        super.init(collectionViewLayout: UICollectionViewFlowLayout())
    }
    
    required public init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        setupCollectionView()
        setupNotification()
        fetchKittyFeed()
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        let title = UILabel(frame: CGRect(x: 0, y: 0, width: 80, height: 34))
        title.text = "KittyGram"
        title.textColor = .black
        title.font = UIFont(name: "Billabong", size: 28)
        self.tabBarController?.navigationItem.titleView = title
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(true)
        self.tabBarController?.navigationItem.titleView = nil
    }
}

extension KittyViewController: KittyCellDelegate {
    
    func likeButtonPressed(_ catId: String, isLiked: Bool) {
        //set like or not
        guard let userId = self.userId else { return }
        
        Service.sharedInstance.likeKitty(isLiked, userId: userId, catId: catId, completionHandler: { success in
            if success {
                self.dataSource?.likeTouched(catId, isLiked: isLiked)
            } else {//at error changing back to original value
                self.dataSource?.likeTouched(catId, isLiked: !isLiked)
                 //update: notification about network error on navBar?
                self.showErrWithMsg(errorMsg: "Network connection lost")
            }
//            self.dataSource?.storeFetchedKitties(isFromFeed: true)//storing the fetched values in feed
//            UserDefaults.standard.removeObject(forKey: "likedKittyArray") //NOTES: not the best ideas
            DispatchQueue.main.async(){
                 self.collectionView?.reloadData()
            }
        })
    }
}

extension KittyViewController: UICollectionViewDelegateFlowLayout {
    
    override func numberOfSections(in collectionView: UICollectionView) -> Int {
        return self.dataSource?.numberOfSections() ?? 1
    }
 
    override func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return self.dataSource?.numberOfItems() ?? 0
    }
    
    override func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "kCell", for: indexPath) as! KittyCollectionViewCell
        cell.delegate = self
        cell.kitty = self.dataSource?.kittyAtIndex(indexPath.row)
        return cell
    }
    
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
        let width = self.view.frame.width
        return CGSize(width: width, height: width + 60)
    }
}
